---
title: "Proteomic Workflow"
author: Matthew Hirschey, Alex Adams
output: html_notebook
---

## Load Libraries
```{r}
library(tidyverse)
library(qvalue)
library(svDialogs)
library(pheatmap)
library(ggplot2)
library(reshape2)
library(ggrepel)
library(enrichR)
library(matrixTests)
```

## Import Data
```{r import}
# peptide_groups_raw <- read_tsv("data/ex1_PeptideGroups.txt")
# proteins_raw <- read_tsv("data/ex1_Proteins.txt")
# peptide_groups_raw <- read_tsv("data/ex2_PeptideGroups.txt")
# proteins_raw <- read_tsv("data/ex2_Proteins.txt")
peptide_groups_raw <- read_tsv("data/WT-Input_PeptideIsoforms.txt")
proteins_raw <- read_tsv("data/WT-Input_Proteins.txt")
```

## Clean Data
```{r clean}
# CALCULATE THE NORMALIZATION FACTORS FROM PEPTIDE INPUT ABUNDANCES
user_input <- 2 # How many input groups do you have?
num_inputs <- user_input
norm_list <- vector(mode = "list", length = num_inputs)
input_stringIDs <- vector(mode = "list", length = num_inputs)

for (i in 1:num_inputs){
  user_input <- dlg_input("Enter a string that is specific to and common among the input column names in the raw PEPTIDE data.")$res
  input_stringIDs[[i]] <- user_input
  input_index <- grep(user_input, names(peptide_groups_raw))
  sum <- numeric(length(input_index))
  for (j in 1:length(input_index)){
    sum[j] <- sum(peptide_groups_raw[input_index[j]], na.rm = TRUE)
  }
  avg <- mean(sum)
  norm_list[[i]] <- numeric(length(input_index))
  for (j in 1:length(norm_list[[i]])){
    norm_list[[i]][j] <- sum[j]/avg
  }
}


# INITIALIZE THE FINAL PEPTIDE STATISTICS DATA STRUCTURE
user_input <- 2  # as.numeric(dlg_input("How many experimental plexes does your study have?")$res)
num_groups <- user_input
num_exp <- 3 # number of experimental subgroups per plex
pool <- 2 # number of pool groups
index_list <- vector(mode = "list", length = num_groups)
group_stringIDs <- vector(mode = "list", length = num_groups)

for(i in 1:num_groups){
  user_input <- dlg_input("Enter a string that is specific to and common among all column names for your experimental group PEPTIDE data.")$res
  group_stringIDs[[i]] <- user_input
  index_list[[i]] <- grep(user_input, names(peptide_groups_raw))
}

peptide_stats <- bind_cols(tibble(uniqueID = 1:nrow(peptide_groups_raw)),
                      select(peptide_groups_raw, "Master Protein Accessions"),
                      select(peptide_groups_raw, "Sequence"))

peptide_stats$Accession <- str_split_fixed(peptide_stats$`Master Protein Accessions`, ";", 2)[,1]
peptide_stats <- left_join(peptide_stats, select(proteins_raw, Accession, Description), by = "Accession")
peptide_stats$GN <- str_extract(peptide_stats$Description, "(?<=GN=).*?(?=\\s|$)")

peptide_stats_list <- vector(mode = "list", length = num_groups)
for(i in 1:num_groups){
  peptide_stats_list[[i]] <- bind_cols(peptide_stats, select(peptide_groups_raw, index_list[[i]]))
} 

##### CHECKPOINT ##### peptide_stats_list conserved

# CALCULATE THE NORMALIZED INPUT PROTEIN ABUNDANCES
protein_input_norm <- vector(mode = "list", length = num_inputs)
df <- vector(mode = "list", length = num_inputs)
for (i in 1:num_inputs){
  input_index <- grep(input_stringIDs[[i]], names(proteins_raw))
  protein_input_norm[[i]] <- bind_cols(tibble(uniqueID = 1:nrow(proteins_raw)),
                        select(proteins_raw, "Accession"),
                        select(proteins_raw, "Sequence"),
                        select(proteins_raw, "Master"),
                        select(proteins_raw, input_index))
                        # select(proteins_raw, "Exp. q-value"), <- IN ALLIE'S DATA, THIS COLUMN IS NAMED "Exp. q-value: Combined". NOT SURE OF THE SIGNIFICANCE
  df[[i]] <- bind_cols(select(protein_input_norm[[i]], "uniqueID"),
                  select(protein_input_norm[[i]], grep(input_stringIDs[[i]], names(protein_input_norm[[i]]))))
}
# df <- df[[1]]
# norm <- norm_list[[1]]

### Useful outersect() function that returns the opposite of intersect() ###
outersect <- function(x, y) {
  sort(c(setdiff(x, y),
         setdiff(y, x)))
}

### For this function to work, 'df' is a dataframe with the uniqueID and the raw abundances. The uniqueID allows the output of the function to be joined with the original data set. 'norm' is an array of normalization constants that were calculated earlier. ###
gen_stats <- function(df, norm, num_exp, pool) {
  # CALCULATE THE NORMALIZED ABUNDANCES
  group_names <- toupper(letters[1:num_exp])
  group_size <- (length(df) - pool - 1) / num_exp
  count = 0  
  j = 1
  
  for(i in 2:length(df)){
    df[i] <- df[i]/norm[i-1]
    names(df)[i] <- paste("Normalized ", names(df)[i], "Group =", group_names[j])
    count <- count + 1
    if (count == group_size){
      count <- 0
      j <- j + 1
    }
  }
    
  # CALCULATE THE LOG2 OF NORMALIZED ABUNDANCES
  LOG2 <- log2(df[2:length(df)])
  names(LOG2) <- paste("LOG2 ", names(LOG2))
  df <- bind_cols(df, LOG2)
  
  # CALCULATE THE LOG2 AVERAGE OF NORMALIZED INPUT ABUNDANCES
  df$LOG2_AVG <- rowMeans(select(df, grep("LOG2 ", names(df))))
  
   # CALCULATE THE LOG2-AVG FOR THE NORMALIZED INPUT ABUNDANCES
  LOG2subAVG <- select(df, grep("LOG2 ", names(df))) - df$LOG2_AVG
  names(LOG2subAVG) <- gsub("LOG2", "LOG2 - AVG", names(LOG2subAVG))
  df <- bind_cols(df, LOG2subAVG)

  # POOL NORMALIZATIONS, IF POOL IS PRESENT
  if(pool != 0){
    pool_index <- intersect(grep("LOG2 - AVG", names(df)), grep("Group = NA", names(df)))
    df <- add_column(df,
                     Pool_AVG = rowMeans(df[pool_index]))
    LOG2subAVG_poolnorm <- select(df, grep("LOG2 - AVG", names(df))) - df$Pool_AVG
    names(LOG2subAVG_poolnorm) <- gsub("LOG2 - AVG", "Pool Normalized LOG2-AVG", names(LOG2subAVG_poolnorm))
    df <- bind_cols(df, LOG2subAVG_poolnorm)
  }

  # CALCULATE EXPERIMENTAL GROUP STATS, THE LOG2 FOLD CHANGE, AND P-VALUE
  all_index <- grep("LOG2 - AVG", names(df)) # c((length(df)-length(norm)+1):length(df))
  for(i in 0:(num_exp-1)){
    cur_index <- all_index[(i*group_size+1):((i*group_size)+group_size)]
    avg_name <- paste(group_names[i+1], "AVG")
    sd_name <- paste(group_names[i+1], "STDEV")
    df <- add_column(df,
                     C1 = rowMeans(df[cur_index]),
                     C2 = apply(df[cur_index], 1, sd))
    names(df)[names(df) == "C1"] <- avg_name
    names(df)[names(df) == "C2"] <- sd_name
  }
  
  ### P values calculated on non-pool normalized log2-avg normalized samples
  for(i in 1:num_exp){
    if(i==num_exp){
      break
    }
    for(j in (i+1):num_exp){
      fc_name <- paste(group_names[j],
                       "/",
                       group_names[i],
                       "LOG2 Fold Change")
      df <- add_column(df, 
                       C1 = df[grep(paste(group_names[j], "AVG"), names(df))] -
                            df[grep(paste(group_names[i], "AVG"), names(df))])
      names(df)[names(df) == "C1"] <- fc_name
      
      df <- add_column(df,
                       P_VALUE = NA)
      
      X_index <- tail(setdiff(grep(paste("Group =", group_names[i]), names(df)), grep("Pool Normalized", names(df))), group_size)
      Y_index <- tail(setdiff(grep(paste("Group =", group_names[j]), names(df)), grep("Pool Normalized", names(df))), group_size)
      
      df$P_VALUE <- row_t_equalvar(df[X_index],
                                   df[Y_index])$pvalue
      
      df$ADJUSTED_P_VALUE <- p.adjust(df$P_VALUE, "fdr")
      names(df)[names(df) == "P_VALUE"] <- paste(group_names[j],
                                                  "/",
                                                 group_names[i],
                                                 "P_VALUE")
      names(df)[names(df) == "ADJUSTED_P_VALUE"] <- paste(group_names[j],
                                                  "/",
                                                 group_names[i],
                                                 "ADJUSTED_P_VALUE")
      
    }
  }
  return(df)
}

for (i in 1:num_inputs){
  protein_input_norm[[i]] <- left_join(protein_input_norm[[i]], gen_stats(df[[i]], norm_list[[i]], num_exp, pool), by = "uniqueID")
}

# protein_significant <- filter(protein_input_norm, Master == "IsMasterProtein" & `Exp. q-value` < 0.01)
# protein_significant <- mutate(protein_significant, Q_VALUE = p.adjust(protein_significant$P_VALUE, method = "fdr"))



save <- protein_input_norm
save0 <- peptide_stats_list
peptide_stats_list <- save0
i <- 1

### CALCULATE PEPTIDE STATISTICS (AND RELATIVE PEPTIDE OCCUPANCY STATISTICS)
for(i in 1:num_groups){
  if(length(protein_input_norm) == 1){
  peptide_stats_list[[1]] <- left_join(peptide_stats_list[[1]], 
                                       select(protein_input_norm[[1]], "Accession", grep("LOG2 - AVG|LOG2-AVG", names(protein_input_norm[[1]]))), 
                                       by = "Accession")
  }
  else{
    peptide_stats_list[[i]] <- left_join(peptide_stats_list[[i]], 
                                       select(protein_input_norm[[i]], "Accession", grep("LOG2 - AVG|LOG2-AVG", names(protein_input_norm[[i]]))), 
                                       by = "Accession")
  }
  
  index <- grep("LOG2 - AVG|LOG2-AVG", names(peptide_stats_list[[i]]))
  names(peptide_stats_list[[i]])[index] <- paste("Corresponding Protein Abundance /////", names(peptide_stats_list[[i]])[index])
  df <- bind_cols(select(peptide_stats_list[[i]], "uniqueID"),
                  select(peptide_stats_list[[i]], grep(group_stringIDs[[i]], names(peptide_stats_list[[i]]))))
  
  
  if(length(norm_list) == 1){
    peptide_stats_list[[i]] <- left_join(peptide_stats_list[[i]], gen_stats(df, norm_list[[1]], 3, 2), by = "uniqueID")
  }
  else{
    peptide_stats_list[[i]] <- left_join(peptide_stats_list[[i]], gen_stats(df, norm_list[[i]], 3, 2), by = "uniqueID")
  }
  
  
  # CALCULATE THE RELATIVE OCCUPANCY
  
  if (pool == 0){
    LOG2subAVG_REL <- select(peptide_stats_list[[i]], setdiff(grep("LOG2 - AVG", names(peptide_stats_list[[i]])),
                                                        grep("Corresponding Protein Abundance", names(peptide_stats_list[[i]]))))
    names(LOG2subAVG_REL) <- gsub("LOG2 - AVG", "Relative LOG2 - AVG", names(LOG2subAVG_REL))
    LOG2subAVG <- select(peptide_stats_list[[i]], intersect(grep("LOG2 - AVG", names(peptide_stats_list[[i]])),
                                                          grep("Corresponding Protein Abundance", names(peptide_stats_list[[i]]))))
  }
  else{
    LOG2subAVG_REL <- select(peptide_stats_list[[i]], setdiff(grep("LOG2-AVG", names(peptide_stats_list[[i]])),
                                                        grep("Corresponding Protein Abundance", names(peptide_stats_list[[i]]))))
    names(LOG2subAVG_REL) <- gsub("LOG2-AVG", "Relative LOG2 - AVG", names(LOG2subAVG_REL))
    LOG2subAVG <- select(peptide_stats_list[[i]], intersect(grep("LOG2-AVG", names(peptide_stats_list[[i]])),
                                                          grep("Corresponding Protein Abundance", names(peptide_stats_list[[i]]))))
  }
  LOG2subAVG_REL <- LOG2subAVG_REL - LOG2subAVG
  peptide_stats_list[[i]] <- cbind(peptide_stats_list[[i]], LOG2subAVG_REL)
  
  # CALCULATE RELATIVE PBS/OCT-SPECIFIC OCCUPANCY STATS, THE LOG2 FOLD CHANGE, AND P-VALUE
  all_index <- grep("Relative LOG2 - AVG", names(peptide_stats_list[[i]])) # c((length(df)-length(norm)+1):length(df))
  num <- length(all_index)
  group_names <- toupper(letters[1:num_exp])
  group_size <- (num - pool) / num_exp
  
  for(j in 0:(num_exp-1)){
    cur_index <- all_index[(j*group_size+1):((j*group_size)+group_size)]
    avg_name <- paste("Relative", group_names[j+1], "AVG")
    sd_name <- paste("Relative", group_names[j+1], "STDEV")
    peptide_stats_list[[i]] <- add_column(peptide_stats_list[[i]],
                     C1 = rowMeans(peptide_stats_list[[i]][cur_index]),
                     C2 = apply(peptide_stats_list[[i]][cur_index], 1, sd))
    names(peptide_stats_list[[i]])[names(peptide_stats_list[[i]]) == "C1"] <- avg_name
    names(peptide_stats_list[[i]])[names(peptide_stats_list[[i]]) == "C2"] <- sd_name
  }

  for(j in 1:num_exp){
    if(j==num_exp){
      break
    }
    for(k in (j+1):num_exp){
      fc_name <- paste("Relative",
                       group_names[k],
                       "/",
                       group_names[j],
                       "LOG2_FC")
      peptide_stats_list[[i]] <- add_column(peptide_stats_list[[i]], 
                       C1 = peptide_stats_list[[i]][grep(paste(group_names[k], "AVG"), names(peptide_stats_list[[i]]))] -
                         peptide_stats_list[[i]][grep(paste(group_names[j], "AVG"), names(peptide_stats_list[[i]]))])
      names(peptide_stats_list[[i]])[names(peptide_stats_list[[i]]) == "C1"] <- fc_name

      X_index <- tail(grep(paste("Group =", group_names[j]), names(peptide_stats_list[[i]])), group_size)
      Y_index <- tail(grep(paste("Group =", group_names[k]), names(peptide_stats_list[[i]])), group_size)
      
      
      peptide_stats_list[[i]]$P_VALUE <- row_t_equalvar(peptide_stats_list[[i]][X_index],
                                   peptide_stats_list[[i]][Y_index])$pvalue
      
      peptide_stats_list[[i]]$ADJUSTED_P_VALUE <- p.adjust(peptide_stats_list[[i]]$P_VALUE, "fdr")
      
      names(peptide_stats_list[[i]])[names(peptide_stats_list[[i]]) == "P_VALUE"] <- paste("Relative",
                                                 group_names[k],
                                                  "/",
                                                 group_names[j],
                                                 "P_VALUE")
      names(peptide_stats_list[[i]])[names(peptide_stats_list[[i]]) == "ADJUSTED_P_VALUE"] <- paste("Relative", 
                                                                                                    group_names[k],
                                                                                                    "/", 
                                                                                                    group_names[j], 
                                                                                                    "ADJUSTED_P_VALUE")
    }
  }
}



# DEFINE FINAL TABLES
final_peptide_stats <- peptide_stats_list
final_protein_stats <- protein_input_norm

peptide_data <- dplyr::select(final_peptide_stats[[1]], "GN", 75:83)
peptide_data_formatted <- tibble(ID = names(peptide_data)[2:length(names(peptide_data))],
                                 Group = str_sub(names(peptide_data)[2:length(names(peptide_data))], -1))
transposed_data <- t(peptide_data)[2:ncol(peptide_data), ]
colnames(transposed_data) <- peptide_data$GN
rownames(transposed_data) <- NULL
peptide_data_formatted <- cbind(peptide_data_formatted, transposed_data)

```

## Visualize
```{r viz}
# VISUALIZE THE GREATEST LOG2-FOLD CHANGES (BOTH POSITIVE AND NEGATIVE)
user_input <- as.numeric(dlg_input("What is your p-value cutoff? This will be used to generate your volcano plot(s).")$res)
for(i in 1:length(final_peptide_stats)){
  df <- select(final_peptide_stats[[i]], "GN", "Relative LOG2_FOLD_CHANGE", "Relative P_VALUE")
  df <- na.omit(df)
  names(df)[2] <- "REL_LOG2_FOLD_CHANGE"
  names(df)[3] <- "REL_P_VALUE"
  df <- mutate(df, NEG_LOG_P = -log10(df$`REL_P_VALUE`))
  df <- mutate(df, Significance = ifelse(`REL_P_VALUE`<user_input, paste("p-value < ", user_input), "Not Significant"))
  
  
  
  
  print(ggplot(df, aes(`REL_LOG2_FOLD_CHANGE`, `NEG_LOG_P`)) + 
          geom_point(aes(col=Significance),
                     alpha = 0.3,
                     na.rm = TRUE) +
          scale_color_manual(values = c("grey50", "red")) +
          geom_text_repel(data = top_n(df, 20, `NEG_LOG_P`), 
                          aes(label=`GN`),
                          segment.size = 0.2,
                          segment.color = "grey50",
                          point.padding = 1) +
          ylab(~-Log[10]~ "( p-value )") +
          xlab("Relative" ~Log[2]~ "Fold Change") +
          theme_light())
  
  
  dat <- bind_rows(top_n(df, 25, REL_LOG2_FOLD_CHANGE), top_n(df, -25, REL_LOG2_FOLD_CHANGE))
  dat$id <- 1:nrow(dat)
  dat$sigstars <- NA
  for(j in 1:nrow(dat)){
    if(dat$REL_P_VALUE[j] < 0.001){
      dat$sigstars[j] = "***"
    }
    if(0.01 > dat$REL_P_VALUE[j] & dat$REL_P_VALUE[j] > 0.001){
      dat$sigstars[j] = "**"
    }
    if(0.1 > dat$REL_P_VALUE[j] & dat$REL_P_VALUE[j] > 0.01){
      dat$sigstars[j] = "*"
    }
    if(dat$REL_P_VALUE[j] > 0.1){
      dat$sigstars[j] = ""
    }
  }
  
  dat <- arrange(dat, REL_LOG2_FOLD_CHANGE)
    
  print(ggplot(data=dat,
               aes(x=reorder(factor(id), REL_LOG2_FOLD_CHANGE),
                   y=REL_LOG2_FOLD_CHANGE)) + 
          geom_bar(aes(fill = REL_LOG2_FOLD_CHANGE < 0),
                   stat = "identity",
                   width = 0.5) + 
          scale_fill_manual(guide = FALSE,
                            breaks = c(TRUE, FALSE),
                            values=c("green4","red3")) +
          scale_x_discrete(labels=dat$GN) +
          coord_flip() +
          geom_text(data = dat,
                    aes(label = sigstars),
                    nudge_y = (ifelse(dat$REL_LOG2_FOLD_CHANGE<0, (max(abs(dat$REL_LOG2_FOLD_CHANGE))*-0.04), (max(abs(dat$REL_LOG2_FOLD_CHANGE))*0.04)))) +
          ylab("Relative" ~Log[2]~ "Fold Change") + 
          xlab("Gene ID") +
          theme_light())
  
  dat <- left_join(final_protein_stats, select(final_peptide_stats[[1]], Accession, LOG2_FOLD_CHANGE), by = "Accession")
  dat <- na.omit(dat)
  dat <- melt(dat, id = "Accession", measure = c("LOG2_FOLD_CHANGE.y", "LOG2_FOLD_CHANGE.x"))
  dat <- left_join(dat, select(final_protein_stats, Accession, LOG2_FOLD_CHANGE), by = "Accession")
 
  print(ggplot(data = dat, aes(x = reorder(Accession, LOG2_FOLD_CHANGE), y = value, color = variable)) +
          geom_point(alpha = 0.3) + 
          scale_color_manual(values = c("red2", "grey40")) +
          theme(axis.ticks.x = element_blank(),
                axis.text.x = element_blank(),
                panel.grid.major.x = element_blank(),
                panel.grid.major.y = element_line(color = "grey"),
                panel.background = element_rect(fill = "white", color = "grey")) + 
          geom_text_repel(data = top_n(dat, 20, abs(value)), 
                          aes(label=`Accession`),
                          segment.size = 0.2,
                          segment.color = "grey50",
                          point.padding = 1,
                          color = "black") +
          labs(color = "Modifications and Relative Adbundance") +
          xlab("Proteins") +
          ylab("Relative" ~Log[2]~ "Fold Change"))

  
  dat <- top_n(final_peptide_stats[[i]], 100, `Relative LOG2_FOLD_CHANGE`)
  dat <- subset(dat, `Relative LOG2_FOLD_CHANGE` > 0)
  dat <- subset(dat, `Relative P_VALUE` < 0.1)
  if(nrow(dat) > 0){
    dat <- enrichr(genes = dat$GN, databases = "KEGG_2019_Human")$KEGG_2019_Human
    dat <- subset(dat, Adjusted.P.value < 0.3)
    
    print(ggplot(data = dat, aes(x=reorder(Term, -Adjusted.P.value), y = Adjusted.P.value)) +
            geom_col(aes(fill = Adjusted.P.value)) +
            coord_flip() + 
            scale_fill_gradient(low = "green4",
                                high = "grey95") +
            xlab("Pathway") +
            ylab("Adjusted P-Value") +
            theme_light())
  }
  
  
  dat <- top_n(final_peptide_stats[[i]], -100, `Relative LOG2_FOLD_CHANGE`)
  dat <- subset(dat, `Relative LOG2_FOLD_CHANGE` < 0)
  dat <- subset(dat, `Relative P_VALUE` < 0.1)
  if(nrow(dat) > 0){
    dat <- enrichr(genes = dat$GN, databases = "KEGG_2019_Human")$KEGG_2019_Human
    dat <- subset(dat, Adjusted.P.value < 0.3)
  
    dat <- enrichr(genes = c(), databases = "KEGG_2019_Human")$KEGG_2019_Human
      print(ggplot(data = dat, aes(x=reorder(Term, -Adjusted.P.value), y = Adjusted.P.value)) +
            geom_col(aes(fill = Adjusted.P.value)) +
            coord_flip() + 
            scale_fill_gradient(low = "green4",
                                high = "grey95") +
            xlab("Pathway") +
            ylab("Adjusted P-Value") +
            labs("Adjusted P-Value") +
            theme_light())
  }
  
}



```


## Graveyard (After generalizing code)
```{r scale}
 # for(j in 7:ncol(peptide_stats_list[[i]])){
  #   peptide_stats_list[[i]][j] <- peptide_stats_list[[i]][j]/norm[j-6]
  #   names(peptide_stats_list[[i]])[j] <- paste("Normalized ", names(peptide_stats_list[[i]])[j])
  # }

### BEFORE GENERALIZING THE CODE
# phospho_index <- grep("Abundance: F2:", names(peptide_groups_raw))
# acetyl_index <- grep("Abundance: F1:", names(peptide_groups_raw))
# peptide_stats <- bind_cols(tibble(uniqueID = 1:nrow(peptide_groups_raw)),
#                       select(peptide_groups_raw, "Master Protein Accessions"),
#                       tibble("Accession" = NA, Description = NA, GN = NA, .rows = nrow(peptide_groups_raw)),
#                       select(peptide_groups_raw, "Sequence"),
#                       select(peptide_groups_raw, phospho_index),
#                       select(peptide_groups_raw, acetyl_index))
# 
# for(i in 1:nrow(peptide_groups_raw)){
#   peptide_stats$Accession[i] <- unlist(strsplit(peptide_groups_raw$`Master Protein Accessions`[i], "; "))[1]
#   if(!is.na(peptide_stats$Accession[i])){
#     peptide_stats$Description[i] <- filter(proteins_raw, Accession == peptide_stats$Accession[i])$Description
#     peptide_stats$GN[i] <- str_extract(peptide_stats$Description[i], "(?<=GN=).*?(?=\\s|$)")
#   }
# }
# 
# for(i in 7:(6+length(phospho_index))){
#   peptide_stats[i] <- peptide_stats[i]/norm[i-6]
# }
# 
# for(i in 13:(12+length(acetyl_index))){
#   peptide_stats[i] <- peptide_stats[i]/norm[i-12]
# }
### BEFORE MAKING INTO GENERIC FUNCTION "gen_stats"
# input_index <- grep("Abundance: F3:", names(proteins_raw))
# protein_input_norm <- bind_cols(select(proteins_raw, "Accession"),
#                       select(proteins_raw, "Sequence"),
#                       select(proteins_raw, "Master"),
#                       select(proteins_raw, "Exp. q-value"),
#                       select(proteins_raw, input_index))
# 
# for(i in 5:length(protein_input_norm)){
#   protein_input_norm[i] <- protein_input_norm[i]/norm[i-4]
# }
# 
# # CALCULATE THE LOG2 OF NORMALIZED INPUT ABUNDANCES
# protein_input_norm <- bind_cols(protein_input_norm, log2(protein_input_norm[5:length(protein_input_norm)]))
# names(protein_input_norm)[(length(protein_input_norm)-length(input_index)+1):length(protein_input_norm)] <-
#   paste("LOG2 ", names(protein_input_norm)[(length(protein_input_norm)-length(input_index)+1):length(protein_input_norm)])
# 
# # CALCULATE THE LOG2 AVERAGE OF NORMALIZED INPUT ABUNDANCES
# LOG2_AVG <- tibble(LOG2_AVG = NA, .rows = nrow(protein_input_norm))
# for (i in 1:nrow(protein_input_norm)){
#   LOG2_AVG$LOG2_AVG[i] <- mean(as.numeric(protein_input_norm[i, grep("LOG2 ", names(protein_input_norm))]), na.rm = TRUE)
# } 
# protein_input_norm <- bind_cols(protein_input_norm, LOG2_AVG)
# 
# # CALCULATE THE LOG2-AVG FOR THE NORMALIZED INPUT ABUNDANCES
# LOG2_NORM <- select(protein_input_norm, grep("LOG2 ", names(protein_input_norm)))
# names(LOG2_NORM) <- gsub("LOG2", "LOG2-AVG", names(LOG2_NORM))
# for(i in 1:nrow(protein_input_norm)){
#   LOG2_NORM[i,] <- LOG2_NORM[i,] - protein_input_norm$LOG2_AVG[i]
# }
# protein_input_norm <- bind_cols(protein_input_norm, LOG2_NORM)
# 
# # CALCULATE PBS/OCT-SPECIFIC STATS, THE LOG2 FOLD CHANGE, AND P-VALUE
# pbs_index <- intersect(grep("LOG2-AVG", names(protein_input_norm)), grep("PBS", names(protein_input_norm)))
# protein_input_norm <- mutate(protein_input_norm, PBS_AVG = rowMeans(protein_input_norm[pbs_index]))
# 
# oct_index <- intersect(grep("LOG2-AVG", names(protein_input_norm)), grep("Octanoate", names(protein_input_norm)))
# protein_input_norm <- mutate(protein_input_norm, OCT_AVG = rowMeans(protein_input_norm[oct_index]))
# 
# protein_input_norm <- mutate(protein_input_norm, PBS_STDEV = apply(protein_input_norm[pbs_index], 1, sd))
# protein_input_norm <- mutate(protein_input_norm, OCT_STDEV = apply(protein_input_norm[oct_index], 1, sd))
# protein_input_norm <- mutate(protein_input_norm, LOG2_FOLD_CHANGE = protein_input_norm$OCT_AVG - protein_input_norm$PBS_AVG)
# protein_input_norm <- mutate(protein_input_norm, P_VALUE = NA)
# 
# for (i in 1:nrow(protein_input_norm)){
#   if (!(NA %in% as.numeric(protein_input_norm[pbs_index][i,]))){
#     protein_input_norm$P_VALUE[i] <- t.test(as.numeric(protein_input_norm[pbs_index][i,]), 
#                                             as.numeric(protein_input_norm[oct_index][i,]),
#                                             alternative = "two.sided", var.equal = TRUE)$p.val
#   }
# }
# protein_significant <- filter(protein_input_norm, Master == "IsMasterProtein" & `Exp. q-value` < 0.01)
# protein_significant <- mutate(protein_significant, Q_VALUE = p.adjust(protein_significant$P_VALUE, method = "fdr"))
# 
# # CALCULATE STATISTICS FOR PHOSPHOPEPTIDE QUANT, WITH AND WITHOUT NORMALIZATION TO SPECIFIC TRAGET PROTEINS. PULL IN PROTEIN METADATA TO THE PTM LEVEL OUTPUT.
# 
# peptide_stats <- left_join(peptide_stats, select(protein_input_norm, "Accession", grep("LOG2-AVG", names(protein_input_norm))), by = "Accession")
# input_index <- grep("LOG2-AVG", names(peptide_stats))
# 
# phospho_index <- grep("Abundance: F2:", names(peptide_stats))
# peptide_stats_phospho <- select(peptide_stats, "uniqueID", "Accession", "Description", "GN", input_index, phospho_index)
# 
# # CALCULATE THE LOG2 OF PHOSPHOPEPTIDE ABUNDANCES
# peptide_stats_phospho <- bind_cols(peptide_stats_phospho, log2(peptide_stats_phospho[11:length(peptide_stats_phospho)]))
# names(peptide_stats_phospho)[(length(peptide_stats_phospho)-length(phospho_index)+1):length(peptide_stats_phospho)] <-
#   paste("LOG2 ", names(peptide_stats_phospho)[(length(peptide_stats_phospho)-length(phospho_index)+1):length(peptide_stats_phospho)])
# 
# # CALCULATE THE LOG2 AVERAGE OF NORMALIZED INPUT ABUNDANCES
# LOG2_AVG <- tibble(LOG2_AVG = NA, .rows = nrow(peptide_stats_phospho))
# for (i in 1:nrow(peptide_stats_phospho)){
#   LOG2_AVG$LOG2_AVG[i] <- mean(as.numeric(peptide_stats_phospho[i, grep("LOG2 ", names(peptide_stats_phospho))]), na.rm = TRUE)
# } 
# peptide_stats_phospho <- bind_cols(peptide_stats_phospho, LOG2_AVG)
# 
# # CALCULATE THE LOG2-AVG FOR THE NORMALIZED INPUT ABUNDANCES
# LOG2_NORM <- select(peptide_stats_phospho, grep("LOG2 ", names(peptide_stats_phospho)))
# names(LOG2_NORM) <- gsub("LOG2", "LOG2-AVG", names(LOG2_NORM))
# for(i in 1:nrow(peptide_stats_phospho)){
#   LOG2_NORM[i,] <- LOG2_NORM[i,] - peptide_stats_phospho$LOG2_AVG[i]
# }
# peptide_stats_phospho <- bind_cols(peptide_stats_phospho, LOG2_NORM)
# 
# # CALCULATE PBS/OCT-SPECIFIC STATS, THE LOG2 FOLD CHANGE, AND P-VALUE
# pbs_index <- intersect(intersect(grep("LOG2-AVG", names(peptide_stats_phospho)), 
#                        grep("PBS", names(peptide_stats_phospho))), 
#                        grep("Phospho", names(peptide_stats_phospho)))
# peptide_stats_phospho <- mutate(peptide_stats_phospho, PBS_AVG = rowMeans(peptide_stats_phospho[pbs_index]))
# 
# oct_index <- intersect(intersect(grep("LOG2-AVG", names(peptide_stats_phospho)), 
#                        grep("Octanoate", names(peptide_stats_phospho))),
#                        grep("Phospho", names(peptide_stats_phospho)))
# peptide_stats_phospho <- mutate(peptide_stats_phospho, OCT_AVG = rowMeans(peptide_stats_phospho[oct_index]))
# 
# peptide_stats_phospho <- mutate(peptide_stats_phospho, PBS_STDEV = apply(peptide_stats_phospho[pbs_index], 1, sd))
# peptide_stats_phospho <- mutate(peptide_stats_phospho, OCT_STDEV = apply(peptide_stats_phospho[oct_index], 1, sd))
# peptide_stats_phospho <- mutate(peptide_stats_phospho, LOG2_FOLD_CHANGE = peptide_stats_phospho$OCT_AVG - peptide_stats_phospho$PBS_AVG)
# peptide_stats_phospho <- mutate(peptide_stats_phospho, P_VALUE = NA)
# 
# for (i in 1:nrow(peptide_stats_phospho)){
#   if (!(NA %in% as.numeric(peptide_stats_phospho[pbs_index][i,]))){
#     peptide_stats_phospho$P_VALUE[i] <- t.test(as.numeric(peptide_stats_phospho[pbs_index][i,]), 
#                                             as.numeric(peptide_stats_phospho[oct_index][i,]),
#                                             alternative = "two.sided", var.equal = TRUE)$p.val
#   }
# }
# 
# # CALCULATE THE RELATIVE PHOSPHO OCCUPANCY
# LOG2_NORM <- select(peptide_stats_phospho, intersect(grep("LOG2-AVG", names(peptide_stats_phospho)),
#                                                      grep("Phospho", names(peptide_stats_phospho))))
# names(LOG2_NORM) <- gsub("LOG2-AVG", "Relative LOG2-AVG", names(LOG2_NORM))
# 
# LOG2_REL <- select(peptide_stats_phospho, intersect(grep("LOG2-AVG", names(peptide_stats_phospho)),
#                                                     grep("Input", names(peptide_stats_phospho))))
# LOG2_NORM <- LOG2_NORM - LOG2_REL
# peptide_stats_phospho <- bind_cols(peptide_stats_phospho, LOG2_NORM)
# 
# # CALCULATE RELATIVE PBS/OCT-SPECIFIC STATS, THE LOG2 FOLD CHANGE, AND P-VALUE
# pbs_index <- intersect(intersect(grep("Relative LOG2-AVG", names(peptide_stats_phospho)), 
#                        grep("PBS", names(peptide_stats_phospho))), 
#                        grep("Phospho", names(peptide_stats_phospho)))
# peptide_stats_phospho <- mutate(peptide_stats_phospho, RELATIVE_PBS_AVG = rowMeans(peptide_stats_phospho[pbs_index]))
# 
# oct_index <- intersect(intersect(grep("Relative LOG2-AVG", names(peptide_stats_phospho)), 
#                        grep("Octanoate", names(peptide_stats_phospho))),
#                        grep("Phospho", names(peptide_stats_phospho)))
# 
# peptide_stats_phospho <- mutate(peptide_stats_phospho, RELATIVE_OCT_AVG = rowMeans(peptide_stats_phospho[oct_index]))
# 
# peptide_stats_phospho <- mutate(peptide_stats_phospho, RELATIVE_PBS_STDEV = apply(peptide_stats_phospho[pbs_index], 1, sd))
# peptide_stats_phospho <- mutate(peptide_stats_phospho, RELATIVE_OCT_STDEV = apply(peptide_stats_phospho[oct_index], 1, sd))
# peptide_stats_phospho <- mutate(peptide_stats_phospho, RELATIVE_LOG2_FOLD_CHANGE = peptide_stats_phospho$RELATIVE_OCT_AVG -
#                                   peptide_stats_phospho$RELATIVE_PBS_AVG)
# peptide_stats_phospho <- mutate(peptide_stats_phospho, RELATIVE_P_VALUE = NA)
# 
# for (i in 1:nrow(peptide_stats_phospho)){
#   if (!(NA %in% as.numeric(peptide_stats_phospho[pbs_index][i,]))){
#     peptide_stats_phospho$RELATIVE_P_VALUE[i] <- t.test(as.numeric(peptide_stats_phospho[pbs_index][i,]), 
#                                             as.numeric(peptide_stats_phospho[oct_index][i,]),
#                                             alternative = "two.sided", var.equal = TRUE)$p.val
#   }
# }
# 
# 
# 
# # CALCULATE STATISTICS FOR ACETYLPEPTIDE QUANT, WITH AND WITHOUT NORMALIZATION TO SPECIFIC TRAGET PROTEINS. PULL IN PROTEIN METADATA TO THE PTM LEVEL OUTPUT.
# 
# input_index <- grep("LOG2-AVG", names(peptide_stats))
# 
# acetyl_index <- grep("Abundance: F1:", names(peptide_stats))
# peptide_stats_acetyl <- select(peptide_stats, "uniqueID", "Accession", "Description", "GN", input_index, acetyl_index)
# 
# # CALCULATE THE LOG2 OF PHOSPHOPEPTIDE ABUNDANCES
# peptide_stats_acetyl <- bind_cols(peptide_stats_acetyl, log2(peptide_stats_acetyl[11:length(peptide_stats_acetyl)]))
# names(peptide_stats_acetyl)[(length(peptide_stats_acetyl)-length(acetyl_index)+1):length(peptide_stats_acetyl)] <-
#   paste("LOG2 ", names(peptide_stats_acetyl)[(length(peptide_stats_acetyl)-length(acetyl_index)+1):length(peptide_stats_acetyl)])
# 
# # CALCULATE THE LOG2 AVERAGE OF NORMALIZED INPUT ABUNDANCES
# LOG2_AVG <- tibble(LOG2_AVG = NA, .rows = nrow(peptide_stats_acetyl))
# for (i in 1:nrow(peptide_stats_acetyl)){
#   LOG2_AVG$LOG2_AVG[i] <- mean(as.numeric(peptide_stats_acetyl[i, grep("LOG2 ", names(peptide_stats_acetyl))]), na.rm = TRUE)
# } 
# peptide_stats_acetyl <- bind_cols(peptide_stats_acetyl, LOG2_AVG)
# 
# # CALCULATE THE LOG2-AVG FOR THE NORMALIZED INPUT ABUNDANCES
# LOG2_NORM <- select(peptide_stats_acetyl, grep("LOG2 ", names(peptide_stats_acetyl)))
# names(LOG2_NORM) <- gsub("LOG2", "LOG2-AVG", names(LOG2_NORM))
# for(i in 1:nrow(peptide_stats_acetyl)){
#   LOG2_NORM[i,] <- LOG2_NORM[i,] - peptide_stats_acetyl$LOG2_AVG[i]
# }
# peptide_stats_acetyl <- bind_cols(peptide_stats_acetyl, LOG2_NORM)
# 
# # CALCULATE PBS/OCT-SPECIFIC STATS, THE LOG2 FOLD CHANGE, AND P-VALUE
# pbs_index <- intersect(intersect(grep("LOG2-AVG", names(peptide_stats_acetyl)), 
#                                  grep("PBS", names(peptide_stats_acetyl))), 
#                        grep("Acetyl", names(peptide_stats_acetyl)))
# peptide_stats_acetyl <- mutate(peptide_stats_acetyl, PBS_AVG = rowMeans(peptide_stats_acetyl[pbs_index]))
# 
# oct_index <- intersect(intersect(grep("LOG2-AVG", names(peptide_stats_acetyl)), 
#                                  grep("Octanoate", names(peptide_stats_acetyl))),
#                        grep("Acetyl", names(peptide_stats_acetyl)))
# peptide_stats_acetyl <- mutate(peptide_stats_acetyl, OCT_AVG = rowMeans(peptide_stats_acetyl[oct_index]))
# 
# peptide_stats_acetyl <- mutate(peptide_stats_acetyl, PBS_STDEV = apply(peptide_stats_acetyl[pbs_index], 1, sd))
# peptide_stats_acetyl <- mutate(peptide_stats_acetyl, OCT_STDEV = apply(peptide_stats_acetyl[oct_index], 1, sd))
# peptide_stats_acetyl <- mutate(peptide_stats_acetyl, LOG2_FOLD_CHANGE = peptide_stats_acetyl$OCT_AVG - peptide_stats_acetyl$PBS_AVG)
# peptide_stats_acetyl <- mutate(peptide_stats_acetyl, P_VALUE = NA)
# 
# for (i in 1:nrow(peptide_stats_acetyl)){
#   if (!(NA %in% as.numeric(peptide_stats_acetyl[pbs_index][i,]))){
#     peptide_stats_acetyl$P_VALUE[i] <- t.test(as.numeric(peptide_stats_acetyl[pbs_index][i,]), 
#                                                as.numeric(peptide_stats_acetyl[oct_index][i,]),
#                                                alternative = "two.sided", var.equal = TRUE)$p.val
#   }
# }
# 
# # CALCULATE THE RELATIVE PHOSPHO OCCUPANCY
# LOG2_NORM <- select(peptide_stats_acetyl, intersect(grep("LOG2-AVG", names(peptide_stats_acetyl)),
#                                                      grep("Acetyl", names(peptide_stats_acetyl))))
# names(LOG2_NORM) <- gsub("LOG2-AVG", "Relative LOG2-AVG", names(LOG2_NORM))
# 
# LOG2_REL <- select(peptide_stats_acetyl, intersect(grep("LOG2-AVG", names(peptide_stats_acetyl)),
#                                                     grep("Input", names(peptide_stats_acetyl))))
# LOG2_NORM <- LOG2_NORM - LOG2_REL
# peptide_stats_acetyl <- bind_cols(peptide_stats_acetyl, LOG2_NORM)
# 
# # CALCULATE RELATIVE PBS/OCT-SPECIFIC STATS, THE LOG2 FOLD CHANGE, AND P-VALUE
# pbs_index <- intersect(intersect(grep("Relative LOG2-AVG", names(peptide_stats_acetyl)), 
#                                  grep("PBS", names(peptide_stats_acetyl))), 
#                        grep("Acetyl", names(peptide_stats_acetyl)))
# peptide_stats_acetyl <- mutate(peptide_stats_acetyl, RELATIVE_PBS_AVG = rowMeans(peptide_stats_acetyl[pbs_index]))
# 
# oct_index <- intersect(intersect(grep("Relative LOG2-AVG", names(peptide_stats_acetyl)), 
#                                  grep("Octanoate", names(peptide_stats_acetyl))),
#                        grep("Acetyl", names(peptide_stats_acetyl)))
# 
# peptide_stats_acetyl <- mutate(peptide_stats_acetyl, RELATIVE_OCT_AVG = rowMeans(peptide_stats_acetyl[oct_index]))
# 
# peptide_stats_acetyl <- mutate(peptide_stats_acetyl, RELATIVE_PBS_STDEV = apply(peptide_stats_acetyl[pbs_index], 1, sd))
# peptide_stats_acetyl <- mutate(peptide_stats_acetyl, RELATIVE_OCT_STDEV = apply(peptide_stats_acetyl[oct_index], 1, sd))
# peptide_stats_acetyl <- mutate(peptide_stats_acetyl, RELATIVE_LOG2_FOLD_CHANGE = peptide_stats_acetyl$RELATIVE_OCT_AVG -
#                                   peptide_stats_acetyl$RELATIVE_PBS_AVG)
# peptide_stats_acetyl <- mutate(peptide_stats_acetyl, RELATIVE_P_VALUE = NA)
# 
# for (i in 1:nrow(peptide_stats_acetyl)){
#   if (!(NA %in% as.numeric(peptide_stats_acetyl[pbs_index][i,]))){
#     peptide_stats_acetyl$RELATIVE_P_VALUE[i] <- t.test(as.numeric(peptide_stats_acetyl[pbs_index][i,]), 
#                                                         as.numeric(peptide_stats_acetyl[oct_index][i,]),
#                                                         alternative = "two.sided", var.equal = TRUE)$p.val
#   }
# }
```

## Calculate Differences
```{r calc}

```

## Statistics
Consider limma package
```{r stats}

```

## EDA
```{r eda}

```



## Pathway analysis
Consider Enrichr package
```{r pathway}

```

## Output
Export .xls file; or csv? 
Feather file type?
Make a template RMD file, and export a standardized report?
```{r output}

```
